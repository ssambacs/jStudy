# day17

Object 클래스
--> 자바로 만든 클래스들의 최상위 클래스 역할을 하는 클래스이다.
	특별히 하는일은 별로 없고
	자바 상속 관계를 명확하게 하기 위한 역할로 주로 사용이 된다.
	
	1. equals()
		--> 비교 함수이다.
			문제는 Object가 가지고 있는 이 함수는 내용을 비교하는 함수가 아니고
			주소를 비교하는 함수이다.
			연산자중 동등비교연산자와 같은 가능을 가지고 있는 함수이다.
			
		참고
			우리가 String 타입의 데이터를 비교할 때 equals()를 사용해서
			데이터를 비교했었는데..
			이것은 String 이 Object의 equals()를 오버라이드하여
			기능을 데이터를 비교하는 기능으로
			변경시켜놓은 것이다.
			
		참고
			만약 우리가 제작하는 클래스도 내용 비교를 하도록 원하면
			이 함수를 오버라이드 해서 기능을 수정하면 된다.

-------------------------------------------------------------------------------
사용자 정의 예외 클래스 만들기
-->	예외 클래스는 예외의 발생 원인을 알려주는 역할을 담당하낟.
	그런데 어제 강제 예외던지기는 자바가 준비한 예외클래스들만 처리할 수 있다.
	
	만약 우리가 정의한 예외클래스가 있다라고 한다면
	예외의 원인을 파악해주도록 클래스를 작성해야 할 것이다.
	
	사용자 정의 예외클래스는 사용자가 지정한 예외클래스이고
	이 클래스로 예외처리를 할 경우에는 반드시 예외의 원인을 알려주도록 작성해야 하는데
	
	방법
		1. Exception 클래스를 상속 받은 클래스를 제작한다.
		2. toString() 를 오버라이드해서
			예외의 원인을 출력할 수 있도록 한다.
-------------------------------------------------------------------------------
String 클래스
--> 문자열을 관리하는 클래스

	***
	주의사항
		String 클래스의 가장 큰 단점
		--> String 클래스는 내용이 변경이 되면
			변경된 내용을 다시 메모리에 저장하고
			주소를 다시 저장된 메모리의 주소로 바꾼다.
			
		따라서 String의 내용변화가 심하면 메모리를 계속해서 누적 사용게 된다.
		한마디로 메모리의 낭비가 심해진다.
		
		그러므로 
		변경이 잦은 문자열은 StringBuffer 또는 StringBuilder 클래스를 사용해서
		처리하는 것이 좋다.
		
		참고
			그래도 간단한 문자열 처리는 자주 사용하는 클래스이므로
			"클래스 중 유일하게" new 시키지 않고 사용할 수 있도록 준비해 놓은 클래스이다.
			
			String str1 = new String("홍길동");		
			String str2 = "홍길동";		
			==> 두가지 모두 가능하도록 해 놓았다.
			
		참고
			String 클래스는 클래스 중 유일하게
			+ 연산자를 사용가능하도록 해놓았다.
			
-------------------------------------------------------------------------------
오버라이드 규칙
1. 함수의 원형을 유지해야 한다.
2. 접근 지정자는 같거나 넓은 방향으로 해야 한다.
3. 예외처리(예외전이)는 같거나 좁은 방향으로 처리해야 한다.	

예
	void add(int a, int b) throws InvalidNumberExceptoin, NotANumberException{
	}
	
	--> 오버라이드 할때는
		
	void add(int a, int b) throws InvalidNumberExceptoin, NotANumberException{
	}	==> o
	
	void add(int a, int b) throws InvalidNumberExceptoin {
	}	==> o
	
	void add(int a, int b) throws NotANumberException{
	}	==> o
	
	void add(int a, int b) throws Exception{
	}	==> x : 예외의 범위가 더 넓은 방향으로 예외전이를 하도록 하는 오버라이드는 불가능하다.
	
-------------------------------------------------------------------------------
StringBuffer
--> String 과 동일하게 문자열을 관리하는 클래스이다.

	***
	차이점
		String 클래스는 내용이 변화되면 새로운 메모리를 다시 확보하고
		변화된 내용은 다시 기억한 후 주소를 바꾼다.
		--> String 클래스는 잦은 변화가 생기면 메모리가 많이 소모된다.
		
		StringBuffer는 String 의 문제점을 해결하기 위해서
		만들어 놓은 또 하나의 문자열을 관리하는 클래스로
		내용 변화가 있으면 현재 메모리에 변화된 내용을 그대로 기억한다.
		
		StringBuffer는 String과는 다르게 
			대입연산자( = )
			를 사용해서 문자열을 기억하는 것은 불가능하고
			반드시 객체지향 원리에 따라서 
			반드시 new 시켜서 사용해야 한다.
			
			StringBuffer str = "Hong";						--> error
			StringBuffer str = new StringBuffer("Hong");	--> success
			
		참고
			String str = "Hong";
			str = str + "Gil";
			즉 + 연산자를 이용해서 문자열을 결합하는 것 역시
			오직 String 클래스에 한해서 허락한 문법이다.
			
			나머지 클래스는 반드시 그 클래스가 가진 기능(함수)를
			이용해서 필요한 처리를 해줘야 한다.
			
			StringBuffer str = new StringBuffer("Hong");
			str.append(" Gil "); // 원래 기억하던 문자열에 다른 문자열을 결합하는 기능의 함수(append())
		
		참고
			실무에서의 StringBuffer 활용방법
				1. String 이 편리하므로 String 으로 먼저 처리한다ㅏ.(먼저 만든다)
					String str = "Hong";
				2. 문자열의 변화가 일어나는 시점이 되면
					그 순간 StringBuffer 타입으로 변환시킨다.
					
					StringBuffer buff = new StringBuffer(str);
					
				3. StringBuffer 를 이용해서 문자열 변화를 시도한다.
					==> 이때 메모리가 낭비되는 현상이 일어나지 않는다.
					
				4. 문자열 변화가 종료되면 다시 자주 편하게 사용하는 String 클래스 타입으로
					변환시킨다.
					
						str = new String(buff);
						또는
						str = buff.toString();
						
	참고	
		StringBuilder
		--> 이 클래스 역시 StringBuffer와 동일한 역할을 하는 클래스이다.
		
			주로 Thread 처리를 할 때 동기화에 대해서 안정적으로 처리가 가능하다.
			
---------------------------------------------------------------------------------
숙제
	String, StringBuffer, StringBuilder
	클래스가 가지고 있는 주요함수 5개를 조사해서 본인에게 제출하세요.
		내용은 함수의 의미와 사용예제를 만들어보세요.
		

---------------------------------------------------------------------------------
toString()
==> Object 클래스가 가지고 있는 함수로
	Object 클래스에 정의 되어있는 기능은 주소를 비교하는 기능이다.
	
	자바는 주소를 내부적으로 사용하고 있다.
	하지만 주소를 개발자에게 노출하지 않는다.
	
	대신 주소를 출력하면 
		"클래스이름@해쉬코드값"
	의 형태로 출력하게 된다.
	
	참고
		해쉬코드
		--> 자바는 주소를 내부적으로 해쉬테이블을 이용해서 관리한다.
			해쉬코드값은 그 주소를 관리하는 해쉬테이블의 코드값이 된다.
			
		그런데 주소를 출력하려고 하는 순간 위의 형태로 만들어 내야 한다.
		--> 이 작업을 해주는 함수가 바로 toString()이다.	
	
	결론적으로
		toString()는 주소(변수)를 출력할 때 자동 호출되어서
		출력할 내용을 만들어주는 함수이다.
		
	따라서
		우리가 만드는 클래스를 출력할 때
		다른 내용(클래스의 정보를 출력하도록) 하고자 할 경우
		오버라이드해서 사용하면 되겠다.
		
----------------------------------------------------------------------------
Object.clone()
	--> 자기 자신을 깊은 복사
	
		이 함수는 protected 함수이므로
		상속을 받은 클래스나
		같은 패키지에 있는 클래스에서만 사용할 수 있는데
		우리는 java.lang 패키지 내에 클래스를 만드는 것이 아니므로
		상속을 받아야 사용할 수 있다.
		
		그런데 우리가 제작하는 모든 클래스는 Object 클래스를 자동 상속받아서 만드는 클래스이므로
		자동적으로 이 함수를 사용할 수 있게 된다.
		
Object.hashCode()
	--> 자바는 주소를 노출하지 않도록 하기 위해서
		해쉬테이블을 이용해서 주소를 관리한다.
		그 해쉬테이블에 주소를 관리하는 코드값을 알려주는 함수...
		
*****
자바에서 사용하는 모든 데이터는 Object 타입의 변수에 기억 될 수 있다.
하지만 Object 타입으로 기억 된 데이터를 사용할 경우에는
반드시 원래 형태로 강제 형변환을 해서 사용해야 한다.

-----------------------------------------------------------------------------

Math
--> 주로 수학적인 기능을 처리하는 함수로 구성된 클래스이다.
	모든 함수가 static 함수이므로 
	굳이 new 시키지 않아도 사용할 수 있는 클래스이며...
	아예 new 시키지 못하도록 만든 클래스이다.
			 
-----------------------------------------------------------------------------
래퍼클래스(Wrapper Class)
--> 주소를 사용하는 어떤 곳에 value Type을 사용할 수 없는 문제가 생길 수 있다.
	이런 문제를 해결하기 위해서 만들어진 클래스를 레퍼클래스라고 한다.
	즉, 예를 들어 int 를 참조형 타입으로 사용할 수 있도록 하기 위해서 만들어진 클래스
	
	참고
		자바는 Object를 중심으로 계층구조화 해서
		클래스를 이용하도록 만드는 객체지향 언어이다.
		
		그런데 유일하게 Value Type(기본형데이터 : boolean, char, byte, short, int, log, float, )
		만큼은 객체지향원리를 사용하지 않는다.
		따라서 다형성 구현에 있어서 약간의 문제가 생겼다.
		
		예
			void abc(Object o){}
			==> 이 함수는 모든 내용을 처리하도록 만든 함수이다.
				그런데 유일하게 Value Type(기본데이터타입)은 줄수 없게 될 것이다.
				
		참고
			Boxing 과 Unboxing
				
				Boxing이란 Value Type을 주소 타이으로 변환하는 것
					쉬게 말해서 기본데이터타이을 참조형타입으로 변환하는 것을 이야기한다.
				Unboxing이란 Heap 영역에 있는 데이터를 다시 Statack으로 꺼내는 것
					쉽게 말해서 참조형타이의 데이터를 기본데터타입으로 반환하는 것을 이야기한다.
		
		참고
			레퍼클래스란
				Boxing과 Unboxing을 해주기 위한 클래스
				
		참고
			그런데 요사이는 레퍼클래스를 몰라도 된다.
			왜냐하면 자바 버젼 1.4 이후부터 Boxing과 Unboxing이 자동으로 처리된다.	
			
			예
				Integer no = 10; 	// --> Boxing
				int num = no;		// --> Unboxing
				
				두 작업이 자동으로 처리가 된다.
				
				결론적으로
				자바는 내부적으로 모든 정보는 주소(참조형타입으로)로 통일해서 사용할 수 있다.
				
		참고
			하지만 유틸리티적인 몇개의 함수는 아직 이용 가능하므로
			완전히 버려진 클래스는 아니다.
			
			예 Integer.parseInt(), Float.parseFloat()
	
--------------------------------------------------------------------------------
java.util 패키지 내의 유용한 클래스

	1. Objects
		--> 이 클래스는 100% static 함수로만 구성된 클래스
			클래스(객체)를 다룰때 유용한 몇가지 유틸리티적인 함수로 구성된 클래스이다.
			
		예
			boolean isNull(Object obj)
			--> 객체에 내용이 있는지를 확인하는 함수
				즉, new 시킨 결과가 있는지를 확인하는 함수
				
		참고
			null
			--> 주소 변수(참조형변수)에 주소가 없는 상태를 말하는 것이다.
				이것은 찾아갈 대상이 없는 상태이고
				이 말은 곧 이것은 아직 사용할 준비가 되지 않았다는 말이다.
				
		++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
		
	2. Random 클래스
		--> 난수를 발생하는 클래스이다.
			우리가 알고있는 Math.random() 함수 보다는
			좀더 다양한 형태의 난수를 발생할 수 있는 장점이 있다.
			
		참고
			seed
				컴퓨터에서 난수 발생은 그 순간 시레로 난수를 만들어 주는 것이 아니고
				이미 컴퓨터 내부에는 난수 테이블이 존재하고 있다.
				그리고 이 난수 테이블에서 순서대로 꺼내서 주는 역할을 하는 것이다.
				
				seed란? 난수 테이블에서 난수를 꺼내는 위치를 말하는 용어이다.
				
		++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

	3. Arrays 클래스
		--> 역시 100% static 함수로만 구성된 클래스
			배열을 기억하는 함수가 아니고
			배열을 처리할 때 필요한 유틸리티적인 함수들로 구성된 클래스
			
			예	
				sort(???)
				--> 배열에 있는 데이터를 정렬하는 기능을 가진 함수
				
				toString(???)
				--> 배열의 내용을 문자열로 반환해주는 기능을 가진 함수
								
-------------------------------------------------------------------------------

오늘 배웠던 클래스들의 함수를 조사해보세요...
	
	
	
	
	
	
	 







	
	















			