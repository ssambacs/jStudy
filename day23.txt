# day23

SELECT 질의결과 사용하기

	JDBC에서 SELECT 질의명령을 보내면 그 결과(인라인테이블)을
	(이때 인라인테이블은 메모리에 기억된다.)
	ResultSet 이라는 인터페이스가 관리를 하도록 하고 있다.
	
	우리는 ResultSet 이라는 인터페이스를 이용해서
	인라인테이블의 결과중에서 필요한 데이터를 선택해서 사용할 수 있게 된다.
	
	인라인테이블의 결과중 원하는 데이터를 꺼내는 방법은
	"몇번쨰 줄의 몇번째 칸의 데이터를 꺼내라" 가 아니고
	
	"현재 작업줄의 몇번째칸을 꺼내라"
	라는 방식이다.
	(현재 작업줄 : 가상 레코드 포인터라고 말한다.)
	
	주요함수
		1. 가상레코드 포인터(현재 작업 위치)를 이동 시켜야 한다. 
			
			# 절대 이동 방식
			absolute(int row)
				--> 지정한 행으로 이동
			afterLast()
				--> EOF 로 이동하세요
			beforeFirse()
				--> BOF 로 이동
			first()
				--> 1번째 행으로 이동
			last()
				--> 마지막 행으로 이동
				
			----------------------------------
			
			# 상대 이동 방식
			next()
				--> 현재 레코드포인터에서 다음행으로 이동
			previous()
				--> 현재 레코드포인터에서 이전행으로 이동
		
		2. 데이터를 꺼내는 함수
			
			getXXX()
			--> XXX는 꺼낼 데이터를 사용할 데이터타입 이름
				--> 실제 데이터베이스에 지정한 형태가 아니고
					그 데이터를 자바에서 사용하고 싶은 형태로 꺼내면 된다.
					(데이터베이스에 있는 형태와 달라도 상관이 없다.)
					
				예
					나이를 꺼내고 싶다.
					나는 이 나이를 int로 사용하고 싶다.
					--> getInt()
					
					급여를 꺼내고 싶다.
					이때 급여는 소수점이 있는 숫자로 사용하고 싶다.
					getFloat()
			
			주의사항
				이때 꺼내는 방식
					
					1. getXXX(칸의 위치)
						--> 위치로 알려주는 방식
							자바는 인덱스가 0부터 시작하지만
							JDBC 만큼은 인덱스가 1부터 시작한다.	
							
					2. getXXX("필드이름")
						--> 필드 이름으로 꺼내는 방식
				
			주의 
				SELECT 
					ename as 이름
				FROM
					emp;	
					
				의 경우
					getString("ename"); 	-----------> X 안된다.
					getString("이름");		-----------> O 올바른 방법
					
					위치로 꺼내는 방법
					getString(0);			-----------> X
					getString(1);			-----------> O
				
			결론적으로
				SELECT 질의를 실행하면
				먼저 필요한 위치로 레코드 포인터를 이동한 후
				필요한 데이터를 하나씩 꺼내야 한다.	
					
	양방향 이동이 가능한 인라인 테이블을 만드는 방법
	--> Statement가 양방향 스테이트먼트가 되어야 한다.
	
		createStatement(int resultSetType, int resulSetConcurrency)
		를 이용해서 Statement 를 만드어야 양방향 인라인테이블이 만들어질 수 있다.
		
			int resultSetType
				ResultSet.Type_FORWARD_ONLY
				--> 기본값이 전(앞)방향 인라인테이블을 만들어준다.
				ResultSet.TYPE_SCROLL_INSENSITVE
				--> scroll은 가능하나, 변경된 내용은 적용안한다.
				ResultSEt.TYPE_SCROLL_SENSITIV
				--> scroll도 가능하고 변경된 내용도 적용시킨다.
			
			int resulSetConcurrency
				ResultSet.CONCUR_READ_ONLY
				-->JDBC에서는 테이블을 수정할 수 없도록 한다.
				ResultSet.CONCUR_UPDATABLE
				-->JDBC에서 테이블을 수정 가능하도록 한다.	
				
			--> JDBC는 UPDATE, DELETE 질의명령을 실행하지 않고도
				직접 데이터를 수정할 수 있는 기능을 가지고 있다.
				
-----------------------------------------------------------------------------------
 PreparedStatement
 --> 질의 명령을 데이터베이스에게 전달하는 Statement의 일종이다.
 
 	Statement의 문제
 		질의명령을 실행할 때마다 매번 질의명령을 데이터베이스에게 전달하는 형식을 취한다.
 		그런데 질의명령이 긴 경우도 있다.
 		데이터베이스는 네트워크를 이용한다.
 		
 		이런 문제점을 해결하기 위한 다른 Statement가 생겼는데 PreparedStatement 이다.
 		이것은 미리 질의명령을 알려준 후 실행이 필요하면 실행만 해달라고 요구하면 되는
 		즉, 매번 질의명령을 알려줄(다시 전송해야하는) 필요가 없는 Statement 이다.
 		
 		우리가 작업을 하다보면 매번 같은 질의명령을 실행할 필요가 있을 것이다.
 		그런데 일반 Statement는 매번 같은 질의명령이라도 다시 전송해야 한다.
 		이런 경우 미리 질의명령을 알려주는 전용 Statement를 만들어 놓고
 		질의 명령은 보내지 않고 실해안 부탁한다면
 		처리속도가 그만큼 빨라지고 코딩도 편해질 것이다.
 		
 		부가적으로
 		질의명령중 데이터가 바뀌는 부분이 있는 질의명령은
 		질의명령의 구조를 미리 알려주고
 		데이터만 알려주고 질의명령의 실행을 부탁하는 PrepredStatement 를 사용한다.
 		
 	만드는 방법
 		PrepredStatement pstmt = con.prepareStatement();
 			
 	참고
 		자주 사용하는 질의명령이라도 데이터는 달라질 수 있다.
 		이 문제를 해결하는 방법으로
 		질의명령을 만들 때
 		변화되는 데이터부분은 ? 로 대신한다.
 		
 		? 부분만 질의명령을 실행하기 직전에 채워놓고
 		질의명령을 실행하는 방식을 취한다.
 		
 		예
 			
 			String sql = "SELECT * FROM emp WHERE ename = ?";
 
			주의
				? 에는 따옴표(')를 붙이지 않는다.
				--> 데이터를 채우는 명려에서 알아서 처리해주기 때문에...
				
		주요함수
			? 를 채워주는 함수
			
				setXXX(위치, 데이터);
				
				XXX는 채울 데이터의 타입(자바에서의 데이터타입)에 따라서 선택한다.
				위치 : ? 의 위치
				데이터 : 채울 데이터
				
	참고
		Statement 는 속도는 느리지만
		매번 다른 질의 명령(질의명령의 구조가 다른 질의명령)을 처리할 수 있다.
		PreparedStatement는 속도는 빠르지만
		항상 동일한 질의명령(구조)만 처리할 수 있다.
							
					
					
					
					
					
					
					
					
					
					
					
					
		
		
	
	
	
	
	
	
	
	













	
	
	